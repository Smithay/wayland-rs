<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An event queue"><title>EventQueue in wayland_client - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="wayland_client" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../wayland_client/index.html">wayland_<wbr>client</a><span class="version">0.31.11</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Event<wbr>Queue</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a><ul><li><a href="#single-queue-app" title="Single queue app">Single queue app</a></li><li><a href="#multi-thread-multi-queue-app" title="Multi-thread multi-queue app">Multi-thread multi-queue app</a></li><li><a href="#single-queue-guest-library" title="Single-queue guest library">Single-queue guest library</a></li><li><a href="#integrating-the-event-queue-with-other-sources-of-events" title="Integrating the event queue with other sources of events">Integrating the event queue with other sources of events</a></li></ul></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.blocking_dispatch" title="blocking_dispatch">blocking_dispatch</a></li><li><a href="#method.dispatch_pending" title="dispatch_pending">dispatch_pending</a></li><li><a href="#method.flush" title="flush">flush</a></li><li><a href="#method.handle" title="handle">handle</a></li><li><a href="#method.poll_dispatch_pending" title="poll_dispatch_pending">poll_dispatch_pending</a></li><li><a href="#method.prepare_read" title="prepare_read">prepare_read</a></li><li><a href="#method.roundtrip" title="roundtrip">roundtrip</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AsFd-for-EventQueue%3CState%3E" title="AsFd">AsFd</a></li><li><a href="#impl-Debug-for-EventQueue%3CState%3E" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-EventQueue%3CState%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-EventQueue%3CState%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-EventQueue%3CState%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-EventQueue%3CState%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-EventQueue%3CState%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-EventQueue%3CState%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-Downcast-for-T" title="Downcast">Downcast</a></li><li><a href="#impl-DowncastSync-for-T" title="DowncastSync">DowncastSync</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate wayland_<wbr>client</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">wayland_client</a></div><h1>Struct <span class="struct">EventQueue</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/wayland_client/event_queue.rs.html#318-321">Source</a> </span></div><pre class="rust item-decl"><code>pub struct EventQueue&lt;State&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An event queue</p>
<p>This is an abstraction for handling event dispatching, that allows you to ensure
access to some common state <code>&amp;mut State</code> to your event handlers.</p>
<p>Event queues are created through <a href="struct.Connection.html#method.new_event_queue" title="method wayland_client::Connection::new_event_queue"><code>Connection::new_event_queue()</code></a>.</p>
<p>Upon creation, a wayland object is assigned to an event queue by passing the associated <a href="struct.QueueHandle.html" title="struct wayland_client::QueueHandle"><code>QueueHandle</code></a>
as argument to the method creating it. All events received by that object will be processed by that event
queue, when <a href="struct.EventQueue.html#method.dispatch_pending" title="method wayland_client::EventQueue::dispatch_pending"><code>dispatch_pending()</code></a> or
<a href="struct.EventQueue.html#method.blocking_dispatch" title="method wayland_client::EventQueue::blocking_dispatch"><code>blocking_dispatch()</code></a> is invoked.</p>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3><h4 id="single-queue-app"><a class="doc-anchor" href="#single-queue-app">§</a>Single queue app</h4>
<p>If your app is simple enough that the only source of event to process is the Wayland socket and you only
need a single event queue, your main loop can be as simple as this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wayland_client::Connection;

<span class="kw">let </span>connection = Connection::connect_to_env().unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>event_queue = connection.new_event_queue();

<span class="comment">/*
 * Here your initial setup
 */

// And the main loop:
</span><span class="kw">while </span>!state.exit {
    event_queue.blocking_dispatch(<span class="kw-2">&amp;mut </span>state).unwrap();
}</code></pre></div>
<p>The <a href="struct.EventQueue.html#method.blocking_dispatch" title="method wayland_client::EventQueue::blocking_dispatch"><code>blocking_dispatch()</code></a> call will wait (by putting the thread to sleep)
until there are some events from the server that can be processed, and all your actual app logic can be
done in the callbacks of the <a href="trait.Dispatch.html" title="trait wayland_client::Dispatch"><code>Dispatch</code></a> implementations, and in the main <code>loop</code> after the
<a href="struct.EventQueue.html#method.blocking_dispatch" title="method wayland_client::EventQueue::blocking_dispatch"><code>blocking_dispatch()</code></a> call.</p>
<h4 id="multi-thread-multi-queue-app"><a class="doc-anchor" href="#multi-thread-multi-queue-app">§</a>Multi-thread multi-queue app</h4>
<p>In a case where you app is multithreaded and you want to process events in multiple thread, a simple
pattern is to have one <a href="struct.EventQueue.html" title="struct wayland_client::EventQueue"><code>EventQueue</code></a> per thread processing Wayland events.</p>
<p>With this pattern, each thread can use <a href="struct.EventQueue.html#method.blocking_dispatch" title="method wayland_client::EventQueue::blocking_dispatch"><code>EventQueue::blocking_dispatch()</code></a>
on its own event loop, and everything will “Just Work”.</p>
<h4 id="single-queue-guest-library"><a class="doc-anchor" href="#single-queue-guest-library">§</a>Single-queue guest library</h4>
<p>If your code is some library code that will act on a Wayland connection shared by the main program, it is
likely you should not trigger socket reads yourself and instead let the main app take care of it. In this
case, to ensure your <a href="struct.EventQueue.html" title="struct wayland_client::EventQueue"><code>EventQueue</code></a> still makes progress, you should regularly invoke
<a href="struct.EventQueue.html#method.dispatch_pending" title="method wayland_client::EventQueue::dispatch_pending"><code>EventQueue::dispatch_pending()</code></a> which will process the events that were
enqueued in the inner buffer of your <a href="struct.EventQueue.html" title="struct wayland_client::EventQueue"><code>EventQueue</code></a> by the main app reading the socket.</p>
<h4 id="integrating-the-event-queue-with-other-sources-of-events"><a class="doc-anchor" href="#integrating-the-event-queue-with-other-sources-of-events">§</a>Integrating the event queue with other sources of events</h4>
<p>If your program needs to monitor other sources of events alongside the Wayland socket using a monitoring
system like <code>epoll</code>, you can integrate the Wayland socket into this system. This is done with the help
of the <a href="struct.EventQueue.html#method.prepare_read" title="method wayland_client::EventQueue::prepare_read"><code>EventQueue::prepare_read()</code></a> method. You event loop will be a bit more
explicit:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">loop </span>{
    <span class="comment">// flush the outgoing buffers to ensure that the server does receive the messages
    // you've sent
    </span>event_queue.flush().unwrap();

    <span class="comment">// (this step is only relevant if other threads might be reading the socket as well)
    // make sure you don't have any pending events if the event queue that might have been
    // enqueued by other threads reading the socket
    </span>event_queue.dispatch_pending(<span class="kw-2">&amp;mut </span>state).unwrap();

    <span class="comment">// This puts in place some internal synchronization to prepare for the fact that
    // you're going to wait for events on the socket and read them, in case other threads
    // are doing the same thing
    </span><span class="kw">let </span>read_guard = event_queue.prepare_read().unwrap();

    <span class="comment">/*
     * At this point you can invoke epoll(..) to wait for readiness on the multiple FD you
     * are working with, and read_guard.connection_fd() will give you the FD to wait on for
     * the Wayland connection
     */

    </span><span class="kw">if </span>wayland_socket_ready {
        <span class="comment">// If epoll notified readiness of the Wayland socket, you can now proceed to the read
        </span>read_guard.read().unwrap();
        <span class="comment">// And now, you must invoke dispatch_pending() to actually process the events
        </span>event_queue.dispatch_pending(<span class="kw-2">&amp;mut </span>state).unwrap();
    } <span class="kw">else </span>{
        <span class="comment">// otherwise, some of your other FD are ready, but you didn't receive Wayland events,
        // you can drop the guard to cancel the read preparation
        </span>std::mem::drop(read_guard);
    }

    <span class="comment">/*
     * There you process all relevant events from your other event sources
     */
</span>}</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-EventQueue%3CState%3E" class="impl"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#364-569">Source</a><a href="#impl-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.handle" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#375-377">Source</a><h4 class="code-header">pub fn <a href="#method.handle" class="fn">handle</a>(&amp;self) -&gt; <a class="struct" href="struct.QueueHandle.html" title="struct wayland_client::QueueHandle">QueueHandle</a>&lt;State&gt;</h4></section></summary><div class="docblock"><p>Get a <a href="struct.QueueHandle.html" title="struct wayland_client::QueueHandle"><code>QueueHandle</code></a> for this event queue</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dispatch_pending" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#387-389">Source</a><h4 class="code-header">pub fn <a href="#method.dispatch_pending" class="fn">dispatch_pending</a>(
    &amp;mut self,
    data: <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.reference.html">&amp;mut State</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.DispatchError.html" title="enum wayland_client::DispatchError">DispatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Dispatch pending events</p>
<p>Events are accumulated in the event queue internal buffer when the Wayland socket is read using
the read APIs on <a href="struct.Connection.html" title="struct wayland_client::Connection"><code>Connection</code></a>, or when reading is done from an other thread.
This method will dispatch all such pending events by sequentially invoking their associated handlers:
the <a href="trait.Dispatch.html" title="trait wayland_client::Dispatch"><code>Dispatch</code></a> implementations on the provided <code>&amp;mut D</code>.</p>
<p>Note: this may block if another thread has frozen the queue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.blocking_dispatch" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#398-411">Source</a><h4 class="code-header">pub fn <a href="#method.blocking_dispatch" class="fn">blocking_dispatch</a>(
    &amp;mut self,
    data: <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.reference.html">&amp;mut State</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.DispatchError.html" title="enum wayland_client::DispatchError">DispatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Block waiting for events and dispatch them</p>
<p>This method is similar to <a href="struct.EventQueue.html#method.dispatch_pending" title="method wayland_client::EventQueue::dispatch_pending"><code>dispatch_pending()</code></a>, but if there are no
pending events it will also flush the connection and block waiting for the Wayland server to send an
event.</p>
<p>A simple app event loop can consist of invoking this method in a loop.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.roundtrip" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#420-439">Source</a><h4 class="code-header">pub fn <a href="#method.roundtrip" class="fn">roundtrip</a>(&amp;mut self, data: <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.reference.html">&amp;mut State</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.DispatchError.html" title="enum wayland_client::DispatchError">DispatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Synchronous roundtrip</p>
<p>This function will cause a synchronous round trip with the wayland server. This function will block
until all requests in the queue are sent and processed by the server.</p>
<p>This function may be useful during initial setup of your app. This function may also be useful
where you need to guarantee all requests prior to calling this function are completed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prepare_read" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#456-458">Source</a><h4 class="code-header">pub fn <a href="#method.prepare_read" class="fn">prepare_read</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="backend/struct.ReadEventsGuard.html" title="struct wayland_client::backend::ReadEventsGuard">ReadEventsGuard</a>&gt;</h4></section></summary><div class="docblock"><p>Start a synchronized read from the socket</p>
<p>This is needed if you plan to wait on readiness of the Wayland socket using an event
loop. See the <a href="struct.EventQueue.html" title="struct wayland_client::EventQueue"><code>EventQueue</code></a> and <a href="backend/struct.ReadEventsGuard.html" title="struct wayland_client::backend::ReadEventsGuard"><code>ReadEventsGuard</code></a> docs for details. Once the events are received,
you’ll then need to dispatch them from the event queue using
<a href="struct.EventQueue.html#method.dispatch_pending" title="method wayland_client::EventQueue::dispatch_pending"><code>EventQueue::dispatch_pending()</code></a>.</p>
<p>If this method returns <a href="https://doc.rust-lang.org/1.88.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>, you should invoke <a href="struct.EventQueue.html#method.dispatch_pending" title="method wayland_client::EventQueue::dispatch_pending">’dispatch_pending()`</a>
before trying to invoke it again.</p>
<p>If you don’t need to manage multiple event sources, see
<a href="struct.EventQueue.html#method.blocking_dispatch" title="method wayland_client::EventQueue::blocking_dispatch"><code>blocking_dispatch()</code></a> for a simpler mechanism.</p>
<p>This method is identical to <a href="struct.Connection.html#method.prepare_read" title="method wayland_client::Connection::prepare_read"><code>Connection::prepare_read()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flush" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#464-466">Source</a><h4 class="code-header">pub fn <a href="#method.flush" class="fn">flush</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.unit.html">()</a>, <a class="enum" href="backend/enum.WaylandError.html" title="enum wayland_client::backend::WaylandError">WaylandError</a>&gt;</h4></section></summary><div class="docblock"><p>Flush pending outgoing events to the server</p>
<p>This needs to be done regularly to ensure the server receives all your requests.
/// This method is identical to <a href="struct.Connection.html#method.flush" title="method wayland_client::Connection::flush"><code>Connection::flush()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.poll_dispatch_pending" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#545-568">Source</a><h4 class="code-header">pub fn <a href="#method.poll_dispatch_pending" class="fn">poll_dispatch_pending</a>(
    &amp;mut self,
    cx: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.88.0/core/task/wake/struct.Context.html" title="struct core::task::wake::Context">Context</a>&lt;'_&gt;,
    data: <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.reference.html">&amp;mut State</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/task/poll/enum.Poll.html" title="enum core::task::poll::Poll">Poll</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.88.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.88.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a>, <a class="enum" href="enum.DispatchError.html" title="enum wayland_client::DispatchError">DispatchError</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Attempt to dispatch events from this queue, registering the current task for wakeup if no
events are pending.</p>
<p>This method is similar to <a href="struct.EventQueue.html#method.dispatch_pending" title="method wayland_client::EventQueue::dispatch_pending"><code>dispatch_pending()</code></a>; it will not
perform reads on the Wayland socket.  Reads on the socket by other tasks or threads will
cause the current task to wake up if events are pending on this queue.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_channel::mpsc::Receiver;
<span class="kw">use </span>futures_util::future::{poll_fn,select};
<span class="kw">use </span>futures_util::stream::StreamExt;
<span class="kw">use </span>wayland_client::EventQueue;

<span class="kw">struct </span>Data;

<span class="kw">enum </span>AppEvent {
    SomethingHappened(u32),
}

<span class="kw">impl </span>Data {
    <span class="kw">fn </span>handle(<span class="kw-2">&amp;mut </span><span class="self">self</span>, event: AppEvent) {
        <span class="comment">// actual event handling goes here
    </span>}
}

<span class="comment">// An async task that is spawned on an executor in order to handle events that need access
// to a specific data object.
</span><span class="kw">async fn </span>run(data: <span class="kw-2">&amp;mut </span>Data, <span class="kw-2">mut </span>wl_queue: EventQueue&lt;Data&gt;, <span class="kw-2">mut </span>app_queue: Receiver&lt;AppEvent&gt;)
    -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>std::error::Error&gt;&gt;
{
    <span class="kw">use </span>futures_util::future::Either;
    <span class="kw">loop </span>{
        <span class="kw">match </span>select(
            poll_fn(|cx| wl_queue.poll_dispatch_pending(cx, data)),
            app_queue.next(),
        ).<span class="kw">await </span>{
            Either::Left((res, <span class="kw">_</span>)) =&gt; <span class="kw">match </span>res<span class="question-mark">? </span>{},
            Either::Right((<span class="prelude-val">Some</span>(event), <span class="kw">_</span>)) =&gt; {
                data.handle(event);
            }
            Either::Right((<span class="prelude-val">None</span>, <span class="kw">_</span>)) =&gt; <span class="kw">return </span><span class="prelude-val">Ok</span>(()),
        }
    }
}</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsFd-for-EventQueue%3CState%3E" class="impl"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#357-362">Source</a><a href="#impl-AsFd-for-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/std/os/fd/owned/trait.AsFd.html" title="trait std::os::fd::owned::AsFd">AsFd</a> for <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_fd" class="method trait-impl"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#359-361">Source</a><a href="#method.as_fd" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/std/os/fd/owned/trait.AsFd.html#tymethod.as_fd" class="fn">as_fd</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.88.0/std/os/fd/owned/struct.BorrowedFd.html" title="struct std::os::fd::owned::BorrowedFd">BorrowedFd</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Provides fd from <a href="backend/struct.Backend.html#method.poll_fd" title="method wayland_client::backend::Backend::poll_fd"><code>Backend::poll_fd</code></a> for polling.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-EventQueue%3CState%3E" class="impl"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#350-355">Source</a><a href="#impl-Debug-for-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#352-354">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.88.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.88.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.88.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-EventQueue%3CState%3E" class="impl"><a href="#impl-Freeze-for-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section><section id="impl-RefUnwindSafe-for-EventQueue%3CState%3E" class="impl"><a href="#impl-RefUnwindSafe-for-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section><section id="impl-Send-for-EventQueue%3CState%3E" class="impl"><a href="#impl-Send-for-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section><section id="impl-Sync-for-EventQueue%3CState%3E" class="impl"><a href="#impl-Sync-for-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section><section id="impl-Unpin-for-EventQueue%3CState%3E" class="impl"><a href="#impl-Unpin-for-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section><section id="impl-UnwindSafe-for-EventQueue%3CState%3E" class="impl"><a href="#impl-UnwindSafe-for-EventQueue%3CState%3E" class="anchor">§</a><h3 class="code-header">impl&lt;State&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a>&lt;State&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.88.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.88.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.88.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Downcast-for-T" class="impl"><a href="#impl-Downcast-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Downcast for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_any" class="method trait-impl"><a href="#method.into_any" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into_any</a>(self: <a class="struct" href="https://doc.rust-lang.org/1.88.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;T&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.88.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a>&gt;</h4></section></summary><div class='docblock'>Convert <code>Box&lt;dyn Trait&gt;</code> (where <code>Trait: Downcast</code>) to <code>Box&lt;dyn Any&gt;</code>. <code>Box&lt;dyn Any&gt;</code> can
then be further <code>downcast</code> into <code>Box&lt;ConcreteType&gt;</code> where <code>ConcreteType</code> implements <code>Trait</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_any_rc" class="method trait-impl"><a href="#method.into_any_rc" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into_any_rc</a>(self: <a class="struct" href="https://doc.rust-lang.org/1.88.0/alloc/rc/struct.Rc.html" title="struct alloc::rc::Rc">Rc</a>&lt;T&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.88.0/alloc/rc/struct.Rc.html" title="struct alloc::rc::Rc">Rc</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a>&gt;</h4></section></summary><div class='docblock'>Convert <code>Rc&lt;Trait&gt;</code> (where <code>Trait: Downcast</code>) to <code>Rc&lt;Any&gt;</code>. <code>Rc&lt;Any&gt;</code> can then be
further <code>downcast</code> into <code>Rc&lt;ConcreteType&gt;</code> where <code>ConcreteType</code> implements <code>Trait</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.as_any" class="method trait-impl"><a href="#method.as_any" class="anchor">§</a><h4 class="code-header">fn <a class="fn">as_any</a>(&amp;self) -&gt; &amp;(dyn <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> + 'static)</h4></section></summary><div class='docblock'>Convert <code>&amp;Trait</code> (where <code>Trait: Downcast</code>) to <code>&amp;Any</code>. This is needed since Rust cannot
generate <code>&amp;Any</code>’s vtable from <code>&amp;Trait</code>’s.</div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_mut" class="method trait-impl"><a href="#method.as_any_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">as_any_mut</a>(&amp;mut self) -&gt; &amp;mut (dyn <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> + 'static)</h4></section></summary><div class='docblock'>Convert <code>&amp;mut Trait</code> (where <code>Trait: Downcast</code>) to <code>&amp;Any</code>. This is needed since Rust cannot
generate <code>&amp;mut Any</code>’s vtable from <code>&amp;mut Trait</code>’s.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DowncastSync-for-T" class="impl"><a href="#impl-DowncastSync-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; DowncastSync for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> + <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_any_arc" class="method trait-impl"><a href="#method.into_any_arc" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into_any_arc</a>(self: <a class="struct" href="https://doc.rust-lang.org/1.88.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;T&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.88.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> + <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>&gt;</h4></section></summary><div class='docblock'>Convert <code>Arc&lt;Trait&gt;</code> (where <code>Trait: Downcast</code>) to <code>Arc&lt;Any&gt;</code>. <code>Arc&lt;Any&gt;</code> can then be
further <code>downcast</code> into <code>Arc&lt;ConcreteType&gt;</code> where <code>ConcreteType</code> implements <code>Trait</code>.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.88.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#806-808">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#810">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#813">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#791-793">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#795">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.88.0/src/core/convert/mod.rs.html#798">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.88.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>